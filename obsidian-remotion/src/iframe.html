<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        * {
            box-sizing: border-box;
        }
        html, body { 
            margin: 0; 
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: system-ui;
            background: #1a1a1a;
            color: #fff;
        }
        #players {
            position: relative;
            width: 100%;
            min-height: 100vh;
            /* Dynamic bottom padding set via JavaScript based on editor viewport height */
            padding-bottom: 600px;
        }
        #players > div {
            position: absolute;
            left: 0;
            right: 0;
            padding: 8px 12px;
            border-radius: 4px;
        }
        #players > div > .player-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1280 / 720;
        }
        #players > div > .player-wrapper > * {
            width: 100%;
        }
        #loading-screen {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a1a;
            z-index: 5000;
        }
        #loading-screen.hidden {
            display: none;
        }
        .loading-spinner {
            font-size: 64px;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-spinner">‚è≥</div>
    </div>
    <div id="players"></div>
    <script>
        // State management
        let typecheckState = { status: 'loading', errorCount: 0 };
        let bundleState = { status: 'loading', error: null };
        let hasContent = false;

        // Module registry for require polyfill
        const __modules__ = {};
        
        // Minimal require polyfill - checks __modules__ and window globals
        function require(id) {
            if (__modules__[id]) return __modules__[id];
            if (window[id]) return window[id];
            if (window.__REMOTION_DEPS__ && window.__REMOTION_DEPS__[id]) return window.__REMOTION_DEPS__[id];
            throw new Error('Module not found: ' + id);
        }
        
        window.__REMOTION_DEPS__ = window.__REMOTION_DEPS__ || {};
        let __root = null;

        function notifyStatusUpdate() {
            // Send status to parent for Obsidian status bar
            window.parent.postMessage({
                type: 'status-update',
                typecheck: typecheckState,
                bundle: bundleState,
            }, '*');
        }

        function showLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.remove('hidden');
            }
            hasContent = false;
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
            hasContent = true;
        }

        function resetPanel() {
            // Unmount React root before clearing
            if (__root) {
                try {
                    __root.unmount();
                } catch (e) {
                    // Ignore unmount errors
                }
                __root = null;
            }
            
            // Clear all state
            const playersEl = document.getElementById('players');
            if (playersEl) {
                playersEl.innerHTML = '';
            }
            clearError();
            
            // Reset status
            typecheckState = { status: 'loading', errorCount: 0 };
            bundleState = { status: 'loading', error: null };
            hasContent = false;
            
            // Show loading screen
            showLoadingScreen();
            updateStatusBar();
        }

        function renderEmptyState() {
            // Unmount React root before clearing
            if (__root) {
                try {
                    __root.unmount();
                } catch (e) {
                    // Ignore unmount errors
                }
                __root = null;
            }
            
            const playersEl = document.getElementById('players');
            if (!playersEl) return;

            playersEl.innerHTML = `
                <div style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    min-height: 100vh;
                    padding: 40px;
                    text-align: center;
                    color: #888;
                ">
                    <div>
                        <div style="font-size: 48px; margin-bottom: 16px;">üìπ</div>
                        <div style="font-size: 18px; font-weight: 500; margin-bottom: 8px;">No Previews</div>
                        <div style="font-size: 14px; line-height: 1.5; max-width: 400px;">
                            Add a TypeScript/TSX code block with a <code style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">preview()</code> call to see Remotion content here.
            notifyStatusUpdateiv>
                    </div>
                </div>
            `;
        }

        function renderPlayers(sequence, previewLocations) {
            const deps = window.__REMOTION_DEPS__ || {};
            const React = deps.react;
            const PlayerModule = deps['@remotion/player'];
            const Player = (PlayerModule && PlayerModule.Player) || (PlayerModule && PlayerModule.default) || PlayerModule;
            const ReactDomClient = deps['react-dom/client'] || deps['react-dom'];
            const playersEl = document.getElementById('players');

            if (!React || !ReactDomClient || !Player || !playersEl) {
                throw new Error('Missing React, ReactDOM, or @remotion/player');
            }

            const createRoot = ReactDomClient.createRoot || ReactDomClient.unstable_createRoot;
            if (createRoot && !__root) {
                __root = createRoot(playersEl);
            }

            // Default player options (must match PREVIEW_DEFAULTS in preview.ts)
            const DEFAULT_OPTIONS = {
                durationInFrames: 150,
                fps: 30,
                compositionWidth: 1280,
                compositionHeight: 720,
                controls: true,
                loop: false,
                autoPlay: false,
            };

            const scenes = (sequence && sequence.scenes) || [];
            
            // Use preview locations as position anchors
            // Each preview() call in the source maps to a component to display
            const initialPositions = [];
            
            scenes.forEach((scene, idx) => {
                const loc = previewLocations && previewLocations[idx];
                const top = loc ? loc.topOffset : (idx * 500);
                initialPositions.push(top);
            });

            const nodes = scenes.map((scene, idx) => {
                const loc = previewLocations && previewLocations[idx];
                // Merge preview location options with defaults
                const playerOptions = loc && loc.options
                    ? { ...DEFAULT_OPTIONS, ...loc.options }
                    : DEFAULT_OPTIONS;

                return React.createElement(
                    'div',
                    { 
                        key: scene.id, 
                        'data-scene-id': scene.id,
                        'data-preview-line': (loc && loc.line) || 0,
                        style: { 
                            top: initialPositions[idx] + 'px',
                        }
                    },
                    React.createElement(
                        'div',
                        { className: 'player-wrapper' },
                        React.createElement(Player, {
                            component: scene.component,
                            durationInFrames: playerOptions.durationInFrames,
                            fps: playerOptions.fps,
                            compositionWidth: playerOptions.compositionWidth,
                            compositionHeight: playerOptions.compositionHeight,
                            controls: playerOptions.controls,
                            loop: playerOptions.loop,
                            autoPlay: playerOptions.autoPlay,
                            acknowledgeRemotionLicense: true,
                            style: { width: '100%' },
                        })
                    )
                );
            });

            if (__root) {
                __root.render(React.createElement(React.Fragment, null, ...nodes));
            } else if (ReactDomClient.render) {
                ReactDomClient.render(React.createElement(React.Fragment, null, ...nodes), playersEl);
            }

            // After rendering, adjust positions based on actual heights to prevent overlap
            // Use setTimeout to ensure React has fully rendered the players
            setTimeout(() => {
                const MIN_SPACING = 16;
                const playerElements = Array.from(playersEl.querySelectorAll('[data-scene-id]'));
                const adjustedPositions = [];
                let lastBottom = 0;

                playerElements.forEach((el, idx) => {
                    const desiredTop = initialPositions[idx];
                    const actualHeight = el.getBoundingClientRect().height;
                    
                    // If desired position would cause overlap, push it down
                    const actualTop = Math.max(desiredTop, lastBottom + MIN_SPACING);
                    adjustedPositions.push(actualTop);
                    lastBottom = actualTop + actualHeight;
                    
                    // Apply adjusted position
                    el.style.top = actualTop + 'px';
                });

                // Update container min-height but preserve padding-bottom
                const currentPadding = parseInt(playersEl.style.paddingBottom || '600');
                playersEl.style.minHeight = (lastBottom + currentPadding) + 'px';
            }, 100);
        }

        function renderError(errorMessage, errorStack) {
            // Show error overlay without clearing existing players
            const playersEl = document.getElementById('players');
            if (!playersEl) return;

            // Remove any existing error overlay first
            const existingOverlay = document.getElementById('error-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Create error overlay that sits on top of existing content
            const overlay = document.createElement('div');
            overlay.id = 'error-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 40px;
                z-index: 10000;
            `;
            
            overlay.innerHTML = `
                <div style="
                    background: rgba(255, 50, 50, 0.1);
                    border: 1px solid rgba(255, 50, 50, 0.3);
                    border-radius: 8px;
                    padding: 24px;
                    max-width: 600px;
                    width: 100%;
                ">
                    <div style="font-size: 18px; font-weight: 600; margin-bottom: 12px; color: #ff6b6b;">‚ö†Ô∏è Runtime Error</div>
                    <div style="font-size: 14px; line-height: 1.5; color: #ffcccc; margin-bottom: 12px;">${errorMessage}</div>
                    ${errorStack ? `<details style="margin-top: 12px;"><summary style="cursor: pointer; color: #ffaaaa; font-size: 12px;">Stack Trace</summary><pre style="font-size: 11px; overflow: auto; margin-top: 8px; color: #ffcccc;">${errorStack}</pre></details>` : ''}
                </div>
            `;
            
            document.body.appendChild(overlay);
        }

        function clearError() {
            const existingOverlay = document.getElementById('error-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }

        function loadBundle(code, previewLocations) {
            try {
                window.RemotionBundle = undefined;
                // eslint-disable-next-line no-eval
                eval(code);
                const mod = window.RemotionBundle;
                let sequence = (mod && mod.default) || mod;
                
                // If no explicit default export, build scenes from preview() calls
                if (!sequence || !sequence.scenes) {
                    const previewComponents = globalThis.__previewComponents || [];
                    const previewOptions = globalThis.__previewOptions || [];
                    
                    if (previewComponents.length > 0) {
                        const scenes = previewComponents.map((component, i) => ({
                            id: '__scene_' + i,
                            component: component,
                            options: previewOptions[i] || {},
                        }));
                        sequence = { scenes };
                    } else {
                        // No previews - show empty state (clear content first)
                        const playersEl = document.getElementById('players');
                        if (playersEl) {
                            playersEl.innerHTML = '';
                        }
                        renderEmptyState();
                        clearError();
                        hideLoadingScreen();
                        return;
                    }
                }
                
                // Success - clear any error overlay and render players
                clearError();
                hideLoadingScreen();
                renderPlayers(sequence, previewLocations);
            } catch (err) {
                const message = err && err.message ? err.message : String(err);
                const stack = err && err.stack ? err.stack : '';
                // Show error overlay but keep existing players (or loading screen if no content yet)
                if (hasContent) {
                    renderError(message, stack);
                } else {
                    hideLoadingScreen();
                    renderError(message, stack);
                }
                window.parent.postMessage({
                    type: 'runtime-error',
                    error: { message, stack }
                }, '*');
            }
        }

        window.addEventListener('message', (event) => {
            const data = event.data;
            if (!data) return;
            
            if (data.type === 'reset') {
                resetPanel();
            } else if (data.type === 'typecheck-status') {
                typecheckState.status = data.status;
                typecheckState.errorCount = data.errorCount || 0;
                notifyStatusUpdate();
            } else if (data.type === 'bundle-status') {
                bundleState.status = data.status;
                bundleState.error = data.error || null;
                notifyStatusUpdate();
            } else if (data.type === 'bundle-output') {
                if (data.payload) {
                    loadBundle(data.payload, data.previewLocations || []);
                }
            } else if (data.type === 'sync-scroll') {
                // Update bottom padding if viewport height is provided
                if (data.viewportHeight) {
                    const playersEl = document.getElementById('players');
                    if (playersEl) {
                        // Match editor behavior: allow last content to scroll to top
                        const padding = Math.max(data.viewportHeight - 200, 400);
                        playersEl.style.paddingBottom = padding + 'px';
                    }
                }
                window.scrollTo({ top: data.scrollTop, behavior: 'auto' });
            }
        });

        // Send scroll events from iframe to parent
        let scrollTimeout = null;
        window.addEventListener('scroll', () => {
            if (scrollTimeout) clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                window.parent.postMessage({
                    type: 'iframe-scroll',
                    scrollTop: window.scrollY
                }, '*');
            }, 5);
        });

        window.parent.postMessage({ type: 'iframe-ready' }, '*');
    </script>
</body>
</html>
